# 7.1 定义和意义

那些使用互斥量、条件变量，以及期望值进行同步的算法和数据结构称为阻塞算法和数据结构。应用会调用库函数, 而库函数将会挂起执行线程，直到其他线程完成某个特定的动作。这些库调用称为阻塞调用, 因为该线程不能越过该点, 直到阻塞被移除。典型的，操作系统会完全挂起一个阻塞线程(并将其时间片交给其他线程)，直到其被其他线程“解阻塞”；“解阻塞”的方式很多，比如解锁一个互斥锁、通知条件变量达成，或让“期望”就绪。

不使用阻塞库函数的数据结构和算法被称为非阻塞的。不过，不是所有的非阻塞的数据结构都是无锁的，那么就让我们见识一下各种各样的无阻塞数据结构吧！

## 7.1.1 非阻塞数据结构

在第5章中，我们使用`std::atomic_flag`实现了一个简单的自旋锁。一起回顾一下这段代码。

清单7.1 使用`std::atomic_flag`实现了一个简单的自旋锁

```c++
class spinlock_mutex
{
  std::atomic_flag flag;
public:
  spinlock_mutex():
    flag(ATOMIC_FLAG_INIT)
  {}
  void lock()
  {
    while(flag.test_and_set(std::memory_order_acquire));
  }
  void unlock()
  {
    flag.clear(std::memory_order_release);
  }
};
```

这段代码没有调用任何阻塞函数，lock()只是一致循环调用test_and_set()，直到test_and_set()返回false才停止循环。这就是为什么取名为“自旋锁”的原因——代码“自旋”于循环当中。由于没有阻塞调用，所以任意使用该互斥量来保护共享数据的代码都是非阻塞的。不过，它并不是无锁的。它仍然是一个锁，并且在某个时刻只能被一个线程锁住。但大多数情况下, 仅仅直到是非阻塞的还不够. 你还需要直到应用哪个更准确的术语, 这些类型有：

* 无阻碍(Obstruction-Free)——如果所有其他线程都暂停了，任何给定的线程都将在一定步骤内完成其操作。
* 无锁(Lock-Free)——如果多个线程对一个数据结构进行操作，经过一定时间后，其中一个线程将完成其操作。
* 无等待(Wait-Free)——即使有其他线程也在对该数据结构进行操作，每个线程都将在一定的时间内完成其操作。

大多数情况下无阻碍算法不是特别有用——其他线程都暂停的情况太少见了，因此这种方式用于描述一个失败的无锁实现更为合适。从无锁结构开始，来了解这些特性到都涉及到了哪些数据结构。

## 7.1.2 无锁数据结构

要使数据结构符合无锁的条件，必须有多个线程能够同时访问该数据结构。他们不能做相同的操作；一个无锁队列可能允许一个线程进行压入数据，另一个线程弹出数据，当有两个线程同时尝试添加元素时，这个数据结构将被破坏。不仅如此，当其中一个访问线程被调度器中途挂起时，其他线程必须能够继续完成自己的工作，而无需等待挂起线程。

使用了“比较/交换”操作的数据结构，通常都有循环。使用“比较/交换”操作的原因：当有其他线程同时对指定的数据进行修改时，此时在尝试再次调用"比较/交换"操作前, 代码将需要重做部分操作。当其他线程被挂起时，如果“比较/交换”操作最终会成功，那么本代码仍然是无锁的。当执行失败时，就需要一个自旋锁，且这个结构就是“非阻塞-有锁”的结构。

无锁算法中的循环会让一些线程处于“饥饿”状态。如有线程在“错误”时间执行，尽管其他线程可能正常运行, 但第一个线程将会不停的尝试所要完成的操作。“无锁-无等待”数据结构的出现，就为了避免这种问题。

## 7.1.3 无等待数据结构

无等待数据结构：首先是无锁数据结构，并且每个线程都能在有限的时间内完成操作，而不用管其他线程的行为。如果算法会由于与其他线程的冲突, 而可能进行无限次重试, 那么它就不是无等待的。本章的大多数例子都有一种特性——对compare_exchange_weak或compare_exchange_strong操作进行循环，并且循环次数没有上限。操作系统对线程进行进行管理，造成有些线程的循环次数非常多，有些线程的循环次数就非常少。因此，这些操作时无等待的。

正确实现一个无等待结构十分困难的，要保证每个线程都能在有限的步骤内完成操作，你必须确保每次执行的操作都是一次性的，并且当前线程中的操作不会影响其他线程的操作。这就会让算法中所使用到的操作变的相当复杂。

考虑到实现无锁或无等待的数据结构非常困难，首先需要给出充足的理由; 需要保证收益要大于成本，那么就先来找一下成本和收益的平衡点吧！

## 7.1.4 无锁数据结构的利与弊

使用无锁结构的主要原因：将并发最大化。使用基于锁的容器，总会有可能让线程阻塞并等待另一个线程完成它的操作；通过互斥来阻止并发是互斥锁的全部目的。无锁数据结构中，某些线程可以逐步执行。无等待数据结构中，每一个线程都可以向前运行，不管其他线程在做什么. 这种理想的方式实现起来很难。

使用无锁数据结构的第二个原因就是鲁棒性。当一个线程在持有锁时被终止，那么数据结构将会被永久性的破坏。不过，当线程在无锁数据结构上执行操作，在执行到一半终止时，除了线程本身的数据，没有其他数据丢失, 其他线程依旧可以正常执行。

另一方面，当不能排除多个线程访问数据结构的情况，就需要注意不变量的状态，或选择替代不变量来保持不变量的状态。同时，还需要注意操作的顺序约束。为了避免未定义行为，及相关的数据竞争，必须使用原子操作进行修改。不过，仅使用原子操作是不够的；必须确保修改的结果按照正确的顺序让其他线程看到。

因为，没有任何锁, 死锁问题不会困扰无锁数据结构, 不过会出现活锁问题。活锁的产生是两个线程同时尝试修改数据结构，但每个线程所做的修改操作都会让另一个线程重启，所以两个线程就会陷入循环并再次尝试。试想有两个人要过独木桥，当两个人从两头向中间走的时候，他们会在中间碰到，然后需要再走回出发的地方，再次尝试过独木桥。要打破僵局，除非有人先到独木桥的另一端(或是商量好了，或是走的快，或纯粹是运气)，要不这个循环将一直重复下去。不过活锁的存在时间并不久，因为其依赖于线程调度。所以只是对性能有所消耗，而不是一个长期问题，但这个问题仍需要关注。根据定义，无等待的代码不会被活锁所困扰，因其操作执行步骤有上限。换个角度说，无等待的算法要比等待算法的复杂度高，且即使没有其他线程访问数据结构，也可能需要更多步骤来完成相应操作。

无锁和无等待的代码的缺点：虽然提高了并发访问的能力，减少了单个线程的等待时间，但是其可能会将整体性能拉低。首先，原子操作的无锁代码要慢于无原子操作的代码，原子操作就相当于无锁数据结构中的锁。不仅如此，硬件必须对访问同一个原子变量的线程做数据同步。第8章将看到与“乒乓缓存”相关的原子变量(多个线程访问同时进行访问)，将会形成一个明显的性能瓶颈。提交代码之前，无论是基于锁的数据结构，还是无锁的数据结构，对性能的检查很重要(最坏的等待时间，平均等待时间，整体执行时间或者其他指标)。

让我们先来看几个例子。
