# 5.1 内存模型基础

内存模型：一方面是基本结构，这与内存布局的有关，另一方面就是并发。基础结构对于并发很重要，特别是使用低层原子操作时。所以我将会从基础结构讲起. 在C++中, 就是对象和内存位置。

## 5.1.1 对象和内存位置

一个C++程序中所有数据都是由对象构成。这不是说可以创建一个int的衍生类，或者是基本类型有成员函数，或是像在Smalltalk和Ruby语言那样——“一切都是对象”。这只是对于c++中数据块的一种说法。C++标准定义对象为“一块存储区域”，尽管可以继续为这些对象分配属性，比如它们的类型和生存周期。

一些对象仅仅是基础类型的简单值, 比如int或float。当然，也有用户定义类的实例。一些对象(比如，数组，衍生类的实例，具有非静态数据成员的类实例)拥有子对象，但是其他对象就没有。

无论对象是怎么样的类型，对象都会存储在一个或多个内存位置上。每个内存位置要么是标量类型的对象(子对象)，比如，unsigned short、my_class*, 要么是一个相邻位域的序列。当使用位域时就需要注意：虽然相邻位域中是不同的对象，但仍视其为相同的内存位置。如图5.1所示，将一个struct分解为多个对象，并且展示了每个对象的内存位置。

![](../../images/chapter5/5-1.png)

图5.1 分解一个struct，展示不同对象的内存位置

首先，完整的struct是由多个子对象组成, 分别对应每个数据成员。位域bf1和bf2共享同一个内存位置(int是4字节、32位类型)，并且`std::string`类型的对象s由内部多个内存位置组成，其他成员都拥有自己的内存位置。注意，位域宽度为0的bf3是如何分离bf4，使其(bf4)有自己的内存位置的, 而自身(bf3)并没有内存位置(译者注：图中bf3可能是一个错误展示，在C++和C中规定，宽度为0的一个未命名位域强制下一位域对齐到其下一type边界，其中type是该成员的类型。这里使用命名变量为0的位域，可能只是想展示其与bf4是如何分离的。有关位域的更多可以参考[wiki](https://en.wikipedia.org/wiki/Bit_field)的页面 注: 我认为这里没有问题,  可能是译者没理解)。

这里有四个需要牢记的原则：<br>

1. 每一个变量都是一个对象，包括作为其他对象的成员变量也是对象。<br>
2. 每个对象至少占有一个内存位置。<br>
3. 基本类型的变量只占有一个内存位置(无论类型大小如何，即使他们是相邻的，或是数组的一部分)。<br>
4. 相邻位域是是相同内存位置的一部分。<br>

我确定你会好奇，这些在并发中有什么作用？下面就让我们来见识一下。

## 5.1.2 对象、内存位置和并发

这部分对于C++的多线程来说是至关重要的：所有东西都在内存中。当两个线程访问不同的内存位置时，不会存在任何问题，一切都工作顺利。当两个线程访问同一个内存位置，就要小心了。如果没有线程更新数据，那还好；只读数据不需要保护或同步。当有线程对内存位置上的数据进行修改，那就有可能会产生条件竞争，就如第3章所述的那样。

为了避免条件竞争，两个线程就需要一定的执行顺序。这可以是一个固定的顺序，使得一个访问总是在另一个访问之前，也可以是一个在应用程序运行期间变化的顺序，但可以保证有一些已定义的顺序。第一种方式，如第3章所述，使用互斥量来确定访问的顺序；当同一互斥量在两个线程同时访问前被锁住，那么在同一时间内就只有一个线程能够访问到对应的内存位置，所以后一个访问必须在前一个访问之后(尽管无法事先知道谁在前)。另一种是使用原子操作的同步属性(详见5.2节中对于原子操作的定义)，决定两个线程的访问顺序。使用原子操作来规定顺序在5.3节中会有介绍。当多于两个线程访问同一个内存地址时，每对访问都需要定义一个顺序。

如果不规定两个不同线程对同一内存地址访问的顺序，那么访问就不是原子的；并且，当有线程是“写入者”时，就会产生数据竞争和未定义行为。

以下的声明尤为重要：未定义的行为是C++中最黑暗的角落。根据语言的标准，一旦应用中有任何未定义的行为，就很难预料会发生什么事情；因为，未定义行为是难以预料的。我就知道一个未定义行为的特定实例，让某人的显示器起火的案例。虽然，这种事情应该不会发生在你身上，但是数据竞争绝对是一个严重的错误，需要不惜一切代价避免它。

另一个重点是：当程序对同一内存地址中的数据访问存在竞争，可以使用原子操作来避免未定义行为。当然，这不会影响竞争的产生——原子操作并没有指定访问顺序——但原子操作把程序拉回到定义行为的区域内。

在了解原子操作前，还有一个有关对象和内存地址的概念需要重点了解：修改顺序。

## 5.1.3 修改顺序

C++程序中的每个对象都有一个修改顺序，它由程序中的所有线程对该对象的所有写入组成，并且从对象初始化开始。在大多数情况下，这个顺序会因运行的不同而不同，但是在程序的任何给定执行中，系统中的所有线程都必须遵守这个顺序。如果对象不是一个原子类型(将在5.2节详述)，必须确保有足够的同步操作，来确定每个线程都遵守了变量的修改顺序。如果不同线程看到单个变量的不同值序列的话，那么就遇到了数据竞争或未定义行为(详见5.1.2节)。如果使用原子操作，编译器就有责任去做必要的同步。

这意味着：不允许某些投机行为，因为一旦一个线程按修改顺序访问了一个某个条目，那个线程之后的读操作必须返回较新的值，并且那个线程之后的对那个独享的写操作按照修改顺序必须发生在更靠后。同样的，同一线程上对某个对象写操作之后的读操作，要不就返回写入的值，要不在对象的修改顺序后(也就是在读取后)再写入另一个值(注: 应该是一个(线程1)写操作之后的(线程1)读操作, 获取到的值要么是刚才(线程1)写操作写入的值, 要么是另一个线程(线程2)写入的值(发生在线程1写操作之后, 线程1读操作之前))。虽然，所有线程都需要遵守程序中每个独立对象的修改顺序，但没有必要遵守各个对象间操作的相对顺序。在5.3.3节中会有更多关于不同线程间操作顺序的内容。

所以，什么是原子操作？它如何来规定顺序？接下来的一节中，会揭晓答案。

